<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JS pop quiz</title>
</head>
<body>
    <script>

        // 2. 333 012
        // for (var i=0; i<3 ; i++){
        //     setTimeout(function(){
        //         console.log(i)
        //     },1)
        // };
        // for (let i = 0; i < 3; i++) {
        //     setTimeout(function(){
        //         console.log(i)
        //     },1);
        // }
        // Because of the event queue in JavaScript, the setTimeout callback function is called after the loop has been executed. Since the variable i in the first loop was declared using the var keyword, this value was global. During the loop, we incremented the value of i by 1 each time, using the unary operator ++. By the time the setTimeout callback function was invoked, i was equal to 3 in the first example.
        // In the second loop, the variable i was declared using the let keyword: variables declared with the let (and const) keyword are block-scoped (a block is anything between { }). During each iteration, i will have a new value, and each value is scoped inside the loop.


        // 8. TypeError
        // class Chameleon {
        //     static colorChange(newColor) {
        //         this.newColor = newColor;
        //         return this.newColor;
        //     }
        //     constructor({ newColor = "green" } = {}) {
        //         this.newColor = newColor;
        //     }
        // }
        // const freddie = new Chameleon({ newColor: "purple" });
        // console.log(freddie.colorChange("orange"));
 

        // 9. {}
        // let greeting;
        // greetign = {}; // Typo!
        // console.log(greetign);
        // It logs the object, because we just created an empty object on the global object! When we mistyped greeting as greetign, the JS interpreter actually saw this as global.greetign = {} (or window.greetign = {} in a browser).
        // In order to avoid this, we can use "use strict". This makes sure that you have declared a variable before setting it equal to anything.


        // 11. TypeError
        // function Person(firstName, lastName) {
        //     this.firstName = firstName;
        //     this.lastName = lastName;
        // }
        // const member = new Person("Lydia", "Hallie");
        // Person.getFullName = function() {
        //     return `${this.firstName} ${this.lastName}`;
        // };
        // console.log(member.getFullName());


        // 16. 022
        let number = 0;
        console.log(number++);
        console.log(++number);
        console.log(number);
        //The postfix unary operator ++:
        // 2. Returns the value (this returns 0)Increments the value (number is now 1)
        // The prefix unary operator ++:
        // 2. Increments the value (number is now 2)Returns the value (this returns 2)
        // This returns 0 2 2.


        // 17. 
        function getPersonInfo(one, two, three) {
            console.log(one);
            console.log(two);
            console.log(three);
        }
        const person = "Lydia";
        const age = 21;
        getPersonInfo`${person} is ${age} years old`;
        // If you use tagged template literals, the value of the first argument is always an array of the string values. The remaining arguments get the values of the passed expressions!


        // 18. 
        function checkAge(data) {
            if (data === { age: 18 }) {
                console.log("You are an adult!");
            } else if (data == { age: 18 }) {
                console.log("You are still an adult.");
            } else {
                console.log(`Hmm.. You don't have an age I guess`);
            }
        }
        checkAge({ age: 18 });
        // When testing equality, primitives are compared by their value, while objects are compared by their reference. JavaScript checks if the objects have a reference to the same location in memory.
        // The two objects that we are comparing don't have that: the object we passed as a parameter refers to a different location in memory than the object we used in order to check equality.
        // This is why both { age: 18 } === { age: 18 } and { age: 18 } == { age: 18 } return false.

        
        // 19.
        function getAge(...args) {
            console.log(typeof args);
        }
        getAge(21);
        // The rest parameter (...args.) lets us "collect" all remaining arguments into an array. An array is an object, so typeof args returns "object"


        // 20.
        function getAge() {
            "use strict";
            age = 21;
            console.log(age);
        }
        getAge();
        // With "use strict", you can make sure that you don't accidentally declare global variables. We never declared the variable age, and since we use "use strict", it will throw a reference error. If we didn't use "use strict", it would have worked, since the property age would have gotten added to the global object.


    </script>
</body>
</html>